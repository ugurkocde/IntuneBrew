name: Check App CVEs

on:
  workflow_dispatch:
    inputs:
      full_sync:
        description: 'Run full sync (ignore last sync date)'
        required: false
        default: 'false'
        type: boolean
      specific_app:
        description: 'Sync specific app only (leave empty for all)'
        required: false
        default: ''
        type: string
  schedule:
    - cron: "0 6 * * *" # Run daily at 6 AM UTC

permissions:
  contents: write

jobs:
  check-cves:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests

      - name: Check CVEs for apps
        env:
          NVD_API_KEY: ${{ secrets.NVD_API_KEY }}
          SPECIFIC_APP: ${{ github.event.inputs.specific_app }}
          FULL_SYNC: ${{ github.event.inputs.full_sync }}
        run: |
          cat > check_cves.py << 'PYTHON_SCRIPT'
          import os
          import sys
          import requests
          import json
          import time
          import pathlib
          from datetime import datetime, timedelta
          from typing import Optional, Dict, List, Any, Tuple

          # =============================================================================
          # CONFIGURATION
          # =============================================================================

          NVD_API_KEY = os.environ.get('NVD_API_KEY')
          SPECIFIC_APP = os.environ.get('SPECIFIC_APP', '').strip()
          FULL_SYNC = os.environ.get('FULL_SYNC', 'false').lower() == 'true'

          # Rate limiting: 50 requests per 30 seconds with API key
          REQUEST_DELAY = 0.7  # seconds between requests
          MAX_RETRIES = 3
          RETRY_DELAY = 5  # seconds

          # CVE directory
          CVE_DIR = pathlib.Path('CVE')
          CVE_DIR.mkdir(exist_ok=True)

          # =============================================================================
          # CURATED CPE MAPPINGS
          # =============================================================================
          # Format: app_key -> (vendor, product, [alternative_products])
          # These are verified CPE vendor:product combinations from NVD
          # =============================================================================

          CPE_MAPPINGS: Dict[str, Tuple[str, str, List[str]]] = {
              # Browsers
              "google_chrome": ("google", "chrome", []),
              "mozilla_firefox": ("mozilla", "firefox", []),
              "mozilla_firefox_esr": ("mozilla", "firefox_esr", ["firefox"]),
              "brave": ("brave", "brave", []),
              "microsoft_edge": ("microsoft", "edge_chromium", ["edge"]),
              "arc": ("thebrowser", "arc", []),
              "opera": ("opera", "opera_browser", ["opera"]),
              "vivaldi": ("vivaldi", "vivaldi", []),

              # Communication
              "slack": ("slack", "slack", []),
              "zoom": ("zoom", "zoom", ["meetings"]),
              "microsoft_teams": ("microsoft", "teams", []),
              "discord": ("discord", "discord", []),
              "signal": ("signal", "signal", []),
              "whatsapp": ("whatsapp", "whatsapp", []),
              "webex": ("cisco", "webex_meetings", ["webex"]),
              "webex_teams": ("cisco", "webex_teams", []),
              "mattermost": ("mattermost", "mattermost", []),
              "rocketchat": ("rocket.chat", "rocket.chat", []),
              "wire": ("wire", "wire", []),

              # Development Tools
              "microsoft_visual_studio_code": ("microsoft", "visual_studio_code", []),
              "cursor": ("anysphere", "cursor", []),
              "sublime_text": ("sublimetext", "sublime_text", ["sublime_text_3"]),
              "atom": ("atom", "atom", []),
              "jetbrains_phpstorm": ("jetbrains", "phpstorm", []),
              "jetbrains_rider": ("jetbrains", "rider", []),
              "jetbrains_toolbox": ("jetbrains", "toolbox", []),
              "clion": ("jetbrains", "clion", []),
              "datagrip": ("jetbrains", "datagrip", []),
              "dataspell": ("jetbrains", "dataspell", []),
              "goland": ("jetbrains", "goland", []),
              "webstorm": ("jetbrains", "webstorm", []),
              "iterm2": ("iterm2", "iterm2", []),
              "hyper": ("zeit", "hyper", []),
              "kitty": ("kovidgoyal", "kitty", []),
              "docker_desktop": ("docker", "docker_desktop", ["desktop"]),
              "postman": ("postman", "postman", []),
              "insomnia": ("kong", "insomnia", []),
              "bruno": ("usebruno", "bruno", []),
              "git_credential_manager": ("microsoft", "git_credential_manager", []),
              "github_desktop": ("github", "desktop", []),
              "atlassian_sourcetree": ("atlassian", "sourcetree", []),
              "azure_data_studio": ("microsoft", "azure_data_studio", []),
              "mongodb_compass": ("mongodb", "compass", []),
              "mysql_workbench": ("mysql", "workbench", ["mysql_workbench"]),
              "dbeaver": ("dbeaver", "dbeaver", []),

              # Password Managers
              "1password": ("1password", "1password", ["agilebits"]),
              "bitwarden": ("bitwarden", "desktop", ["bitwarden"]),
              "keepassxc": ("keepassxc", "keepassxc", []),
              "dashlane": ("dashlane", "dashlane", []),
              "lastpass": ("lastpass", "lastpass", []),

              # Security & VPN
              "nordvpn": ("nordvpn", "nordvpn", []),
              "protonvpn": ("protonvpn", "protonvpn", []),
              "tailscale": ("tailscale", "tailscale", []),
              "cloudflare_warp": ("cloudflare", "warp", []),
              "little_snitch": ("obdev", "little_snitch", []),
              "malwarebytes_for_mac": ("malwarebytes", "malwarebytes", []),
              "santa": ("google", "santa", []),
              "cryptomator": ("cryptomator", "cryptomator", []),
              "veracrypt": ("idrix", "veracrypt", []),

              # Productivity
              "notion": ("notion", "notion", []),
              "obsidian": ("obsidian", "obsidian", []),
              "evernote": ("evernote", "evernote", []),
              "joplin": ("joplin", "joplin", []),
              "typora": ("typora", "typora", []),
              "macdown": ("macdown", "macdown", []),
              "xmind": ("xmind", "xmind", []),

              # Office & Documents
              "microsoft_office": ("microsoft", "office", ["365_apps"]),
              "libreoffice": ("libreoffice", "libreoffice", []),
              "adobe_acrobat_reader": ("adobe", "acrobat_reader_dc", ["acrobat_reader", "acrobat"]),
              "adobe_creative_cloud": ("adobe", "creative_cloud_desktop_application", ["creative_cloud"]),
              "nitro_pdf_pro": ("gonitro", "nitro_pdf_pro", ["nitro_pro"]),

              # Media
              "vlc_media_player": ("videolan", "vlc_media_player", []),
              "spotify": ("spotify", "spotify", []),
              "plex": ("plex", "plex_media_server", ["plex"]),
              "jellyfin": ("jellyfin", "jellyfin", []),
              "obs": ("obsproject", "obs_studio", []),
              "handbrake": ("handbrake", "handbrake", []),
              "gimp": ("gimp", "gimp", []),
              "inkscape": ("inkscape", "inkscape", []),
              "blender": ("blender", "blender", []),
              "audacity": ("audacityteam", "audacity", []),
              "kap": ("wulkano", "kap", []),
              "camtasia": ("techsmith", "camtasia", []),
              "snagit": ("techsmith", "snagit", []),

              # Cloud Storage
              "dropbox": ("dropbox", "dropbox", []),
              "google_drive": ("google", "drive", []),
              "onedrive": ("microsoft", "onedrive", []),
              "nextcloud": ("nextcloud", "desktop_client", ["nextcloud"]),
              "synology_drive": ("synology", "drive_client", []),

              # Remote Access
              "anydesk": ("anydesk", "anydesk", []),
              "teamviewer": ("teamviewer", "teamviewer", []),
              "rustdesk": ("rustdesk", "rustdesk", []),
              "parsec": ("parsec", "parsec", []),
              "nomachine": ("nomachine", "nomachine", []),
              "tigervnc": ("tigervnc", "tigervnc", []),
              "remote_desktop_manager": ("devolutions", "remote_desktop_manager", []),
              "splashtop_business": ("splashtop", "splashtop", []),
              "moonlight": ("moonlight-stream", "moonlight", []),

              # Utilities
              "parallels_desktop": ("parallels", "parallels_desktop", []),
              "utm": ("utm", "utm", []),
              "rancher_desktop": ("rancher", "rancher_desktop", []),
              "calibre": ("calibre-ebook", "calibre", []),
              "transmission": ("transmissionbt", "transmission", []),
              "qbittorrent": ("qbittorrent", "qbittorrent", []),
              "wireshark": ("wireshark", "wireshark", []),
              "mitmproxy": ("mitmproxy", "mitmproxy", []),
              "stats": ("exelban", "stats", []),
              "hazel": ("noodlesoft", "hazel", []),
              "privileges": ("sap", "privileges", []),

              # Enterprise
              "citrix_workspace": ("citrix", "workspace_app", ["receiver"]),
              "cisco_jabber": ("cisco", "jabber", []),
              "okta_advanced_server_access": ("okta", "advanced_server_access", []),
              "company_portal": ("microsoft", "company_portal", []),
              "microsoft_auto_update": ("microsoft", "autoupdate", []),

              # Other Popular Apps
              "steam": ("valvesoftware", "steam_client", ["steam"]),
              "canva": ("canva", "canva", []),
              "figma": ("figma", "figma", []),
              "sketch": ("sketch", "sketch", []),
              "asana": ("asana", "asana", []),
              "basecamp": ("basecamp", "basecamp", []),
              "airtable": ("airtable", "airtable", []),
              "miro": ("miro", "miro", []),
              "loom": ("loom", "loom", []),
              "grammarly": ("grammarly", "grammarly", []),
              "deepl": ("deepl", "deepl", []),
              "ollama": ("ollama", "ollama", []),
              "chatgpt": ("openai", "chatgpt", []),
          }

          # =============================================================================
          # CISA KEV CATALOG
          # =============================================================================

          KEV_CATALOG_URL = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"
          kev_cache: Dict[str, Dict] = {}

          def fetch_kev_catalog() -> Dict[str, Dict]:
              """Fetch and cache the CISA KEV catalog."""
              global kev_cache
              if kev_cache:
                  return kev_cache

              print("Fetching CISA KEV catalog...")
              try:
                  response = requests.get(KEV_CATALOG_URL, timeout=30)
                  if response.status_code == 200:
                      data = response.json()
                      vulnerabilities = data.get('vulnerabilities', [])
                      for vuln in vulnerabilities:
                          cve_id = vuln.get('cveID', '').upper()
                          if cve_id:
                              kev_cache[cve_id] = {
                                  'vendor': vuln.get('vendorProject'),
                                  'product': vuln.get('product'),
                                  'vulnerability_name': vuln.get('vulnerabilityName'),
                                  'date_added': vuln.get('dateAdded'),
                                  'due_date': vuln.get('dueDate'),
                                  'known_ransomware_use': vuln.get('knownRansomwareCampaignUse', 'Unknown'),
                                  'notes': vuln.get('notes'),
                              }
                      print(f"Loaded {len(kev_cache)} KEV entries")
                  else:
                      print(f"Failed to fetch KEV catalog: {response.status_code}")
              except Exception as e:
                  print(f"Error fetching KEV catalog: {e}")

              return kev_cache

          def is_kev(cve_id: str) -> Optional[Dict]:
              """Check if a CVE is in the KEV catalog."""
              kev = fetch_kev_catalog()
              return kev.get(cve_id.upper())

          # =============================================================================
          # NVD API FUNCTIONS
          # =============================================================================

          def nvd_request(url: str, params: Dict = None) -> Optional[Dict]:
              """Make a rate-limited request to NVD API with retries."""
              headers = {}
              if NVD_API_KEY:
                  headers['apiKey'] = NVD_API_KEY

              for attempt in range(MAX_RETRIES):
                  try:
                      time.sleep(REQUEST_DELAY)
                      response = requests.get(url, params=params, headers=headers, timeout=60)

                      if response.status_code == 200:
                          return response.json()
                      elif response.status_code == 403:
                          print(f"Rate limited, waiting {RETRY_DELAY * (attempt + 1)} seconds...")
                          time.sleep(RETRY_DELAY * (attempt + 1))
                      elif response.status_code == 404:
                          return None
                      else:
                          print(f"NVD API error {response.status_code}: {response.text[:200]}")
                          if attempt < MAX_RETRIES - 1:
                              time.sleep(RETRY_DELAY)
                  except requests.exceptions.Timeout:
                      print(f"Request timeout, attempt {attempt + 1}/{MAX_RETRIES}")
                      if attempt < MAX_RETRIES - 1:
                          time.sleep(RETRY_DELAY)
                  except Exception as e:
                      print(f"Request error: {e}")
                      if attempt < MAX_RETRIES - 1:
                          time.sleep(RETRY_DELAY)

              return None

          def extract_version_info(config: Dict) -> Dict[str, Any]:
              """Extract version range information from CVE configuration."""
              version_info = {
                  'affected_version_start': None,
                  'affected_version_start_type': None,
                  'affected_version_end': None,
                  'affected_version_end_type': None,
              }

              nodes = config.get('nodes', [])
              for node in nodes:
                  cpe_matches = node.get('cpeMatch', [])
                  for match in cpe_matches:
                      if match.get('vulnerable', False):
                          # Version start
                          if 'versionStartIncluding' in match:
                              version_info['affected_version_start'] = match['versionStartIncluding']
                              version_info['affected_version_start_type'] = 'including'
                          elif 'versionStartExcluding' in match:
                              version_info['affected_version_start'] = match['versionStartExcluding']
                              version_info['affected_version_start_type'] = 'excluding'

                          # Version end
                          if 'versionEndIncluding' in match:
                              version_info['affected_version_end'] = match['versionEndIncluding']
                              version_info['affected_version_end_type'] = 'including'
                          elif 'versionEndExcluding' in match:
                              version_info['affected_version_end'] = match['versionEndExcluding']
                              version_info['affected_version_end_type'] = 'excluding'

                          # If we found version info, return it
                          if any(version_info.values()):
                              return version_info

              return version_info

          def extract_fixed_version(description: str, version_info: Dict) -> Optional[str]:
              """Extract fixed version from description or version info."""
              # If we have version end with excluding type, that's the fixed version
              if version_info.get('affected_version_end') and version_info.get('affected_version_end_type') == 'excluding':
                  return version_info['affected_version_end']

              # Try to extract from description
              import re
              patterns = [
                  r'(?:fixed|patched|resolved|addressed)\s+(?:in\s+)?(?:version\s+)?(\d+(?:\.\d+)+)',
                  r'(?:before|prior to)\s+(?:version\s+)?(\d+(?:\.\d+)+)',
                  r'(?:upgrade|update)\s+to\s+(?:version\s+)?(\d+(?:\.\d+)+)',
                  r'versions?\s+(?:before|prior to|<)\s+(\d+(?:\.\d+)+)',
              ]

              for pattern in patterns:
                  match = re.search(pattern, description, re.IGNORECASE)
                  if match:
                      return match.group(1)

              return None

          def is_macos_relevant(cve_data: Dict, vendor: str, product: str) -> bool:
              """Check if CVE is relevant to macOS platform."""
              configurations = cve_data.get('configurations', [])

              # If no configurations, check description
              if not configurations:
                  description = ""
                  for desc in cve_data.get('descriptions', []):
                      if desc.get('lang') == 'en':
                          description = desc.get('value', '').lower()
                          break

                  # Exclude if explicitly mentions only other platforms
                  exclude_terms = ['windows only', 'linux only', 'android only', 'ios only', 'iphone only']
                  if any(term in description for term in exclude_terms):
                      return False

                  # Include if mentions macOS or doesn't specify platform
                  return True

              # Check CPE configurations for platform
              for config in configurations:
                  nodes = config.get('nodes', [])
                  for node in nodes:
                      cpe_matches = node.get('cpeMatch', [])
                      for match in cpe_matches:
                          cpe = match.get('criteria', '')
                          parts = cpe.split(':')

                          if len(parts) >= 11:
                              cpe_vendor = parts[3].lower()
                              cpe_product = parts[4].lower()
                              target_sw = parts[10].lower() if len(parts) > 10 else '*'
                              target_hw = parts[11].lower() if len(parts) > 11 else '*'

                              # Check if this matches our vendor/product
                              if cpe_vendor == vendor.lower() and cpe_product == product.lower():
                                  # Check platform
                                  if target_sw in ['*', 'macos', 'mac_os', 'mac_os_x', 'darwin']:
                                      return True
                                  if target_hw in ['*', 'mac', 'x86', 'x64', 'arm64']:
                                      return True
                                  # Exclude explicit non-macOS platforms
                                  if target_sw in ['windows', 'linux', 'android', 'ios', 'iphone_os']:
                                      continue

              # Default to including if no explicit exclusion
              return True

          def fetch_cves_for_app(app_key: str, vendor: str, product: str, alt_products: List[str]) -> List[Dict]:
              """Fetch CVEs for an app using its CPE vendor:product."""
              all_cves = []
              seen_cve_ids = set()

              products_to_check = [product] + alt_products

              for prod in products_to_check:
                  # Build CPE match string
                  cpe_match = f"cpe:2.3:a:{vendor}:{prod}:*:*:*:*:*:*:*:*"

                  print(f"  Querying NVD for CPE: {cpe_match}")

                  url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
                  params = {
                      'cpeName': cpe_match,
                      'resultsPerPage': 500,
                  }

                  data = nvd_request(url, params)
                  if not data:
                      continue

                  vulnerabilities = data.get('vulnerabilities', [])
                  total_results = data.get('totalResults', 0)
                  print(f"  Found {total_results} CVEs for {vendor}:{prod}")

                  for vuln in vulnerabilities:
                      cve = vuln.get('cve', {})
                      cve_id = cve.get('id', '')

                      # Skip duplicates
                      if cve_id in seen_cve_ids:
                          continue

                      # Check if relevant to macOS
                      if not is_macos_relevant(cve, vendor, prod):
                          continue

                      seen_cve_ids.add(cve_id)

                      # Extract description
                      description = ""
                      for desc in cve.get('descriptions', []):
                          if desc.get('lang') == 'en':
                              description = desc.get('value', '')
                              break

                      # Extract dates
                      published = cve.get('published', '')
                      last_modified = cve.get('lastModified', '')
                      published_date = published.split('T')[0] if published else None
                      last_modified_date = last_modified.split('T')[0] if last_modified else None

                      # Extract CVSS metrics
                      metrics = cve.get('metrics', {})
                      base_score = None
                      severity = None
                      cvss_version = None
                      cvss_vector = None

                      # Try CVSS 3.1 first, then 3.0, then 2.0
                      for version_key, version_name in [('cvssMetricV31', '3.1'), ('cvssMetricV30', '3.0'), ('cvssMetricV2', '2.0')]:
                          if version_key in metrics and metrics[version_key]:
                              cvss_data = metrics[version_key][0].get('cvssData', {})
                              base_score = cvss_data.get('baseScore')
                              severity = cvss_data.get('baseSeverity')
                              cvss_version = version_name
                              cvss_vector = cvss_data.get('vectorString')

                              # For CVSS 2.0, severity might be in a different location
                              if not severity and version_key == 'cvssMetricV2':
                                  severity = metrics[version_key][0].get('baseSeverity')
                              break

                      # Extract version information
                      configurations = cve.get('configurations', [])
                      version_info = {}
                      for config in configurations:
                          version_info = extract_version_info(config)
                          if any(version_info.values()):
                              break

                      # Extract fixed version
                      fixed_version = extract_fixed_version(description, version_info)

                      # Check KEV status
                      kev_info = is_kev(cve_id)

                      # Build CVE record
                      cve_record = {
                          'cve_id': cve_id,
                          'published_date': published_date,
                          'last_modified_date': last_modified_date,
                          'description': description,
                          'base_score': base_score,
                          'severity': severity,
                          'cvss_version': cvss_version,
                          'cvss_vector': cvss_vector,
                          'affected_version_start': version_info.get('affected_version_start'),
                          'affected_version_start_type': version_info.get('affected_version_start_type'),
                          'affected_version_end': version_info.get('affected_version_end'),
                          'affected_version_end_type': version_info.get('affected_version_end_type'),
                          'fixed_version': fixed_version,
                          'is_kev': kev_info is not None,
                          'kev_date_added': kev_info.get('date_added') if kev_info else None,
                          'kev_due_date': kev_info.get('due_date') if kev_info else None,
                          'kev_ransomware_use': kev_info.get('known_ransomware_use') if kev_info else None,
                          'vendor': vendor,
                          'product': prod,
                      }

                      all_cves.append(cve_record)

              return all_cves

          def sort_cves(cves: List[Dict]) -> List[Dict]:
              """Sort CVEs by severity and date (most critical/recent first)."""
              severity_order = {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3, None: 4}

              def sort_key(cve):
                  # KEV CVEs first
                  kev_priority = 0 if cve.get('is_kev') else 1
                  # Then by severity
                  severity = severity_order.get(cve.get('severity', '').upper() if cve.get('severity') else None, 4)
                  # Then by date (newest first)
                  date = cve.get('published_date') or '1970-01-01'
                  return (kev_priority, severity, -int(date.replace('-', '')))

              return sorted(cves, key=sort_key)

          def save_cve_json(app_key: str, app_name: str, cves: List[Dict]):
              """Save CVEs to JSON file."""
              output = {
                  'app_name': app_name,
                  'app_key': app_key,
                  'last_updated': datetime.now().strftime('%Y-%m-%d'),
                  'total_cves': len(cves),
                  'summary': {
                      'critical': sum(1 for c in cves if c.get('severity', '').upper() == 'CRITICAL'),
                      'high': sum(1 for c in cves if c.get('severity', '').upper() == 'HIGH'),
                      'medium': sum(1 for c in cves if c.get('severity', '').upper() == 'MEDIUM'),
                      'low': sum(1 for c in cves if c.get('severity', '').upper() == 'LOW'),
                      'kev_count': sum(1 for c in cves if c.get('is_kev')),
                  },
                  'vulnerabilities': cves,
              }

              file_path = CVE_DIR / f"{app_key}.json"
              with open(file_path, 'w') as f:
                  json.dump(output, f, indent=2, default=str)

              print(f"  Saved {len(cves)} CVEs to {file_path}")

          # =============================================================================
          # MAIN EXECUTION
          # =============================================================================

          def main():
              if not NVD_API_KEY:
                  print("ERROR: NVD_API_KEY is required. Add it as a repository secret.")
                  print("Get an API key at: https://nvd.nist.gov/developers/request-an-api-key")
                  sys.exit(1)

              print("=" * 60)
              print("IntuneBrew CVE Scanner")
              print("=" * 60)
              print(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}")
              print(f"Full sync: {FULL_SYNC}")
              print(f"Specific app: {SPECIFIC_APP or 'All apps'}")
              print(f"Apps configured: {len(CPE_MAPPINGS)}")
              print("=" * 60)

              # Pre-fetch KEV catalog
              fetch_kev_catalog()

              # Determine which apps to process
              apps_to_process = {}
              if SPECIFIC_APP:
                  if SPECIFIC_APP in CPE_MAPPINGS:
                      apps_to_process[SPECIFIC_APP] = CPE_MAPPINGS[SPECIFIC_APP]
                  else:
                      print(f"ERROR: App '{SPECIFIC_APP}' not found in CPE mappings")
                      print(f"Available apps: {', '.join(sorted(CPE_MAPPINGS.keys()))}")
                      sys.exit(1)
              else:
                  apps_to_process = CPE_MAPPINGS

              # Process each app
              total_apps = len(apps_to_process)
              processed = 0
              errors = []

              for app_key, (vendor, product, alt_products) in apps_to_process.items():
                  processed += 1
                  app_name = ' '.join(word.capitalize() for word in app_key.split('_'))

                  print(f"\n[{processed}/{total_apps}] Processing: {app_name}")
                  print(f"  Vendor: {vendor}, Product: {product}")

                  try:
                      cves = fetch_cves_for_app(app_key, vendor, product, alt_products)

                      if cves:
                          # Sort CVEs
                          sorted_cves = sort_cves(cves)

                          # Save to JSON
                          save_cve_json(app_key, app_name, sorted_cves)

                          # Print summary
                          kev_count = sum(1 for c in cves if c.get('is_kev'))
                          critical = sum(1 for c in cves if c.get('severity', '').upper() == 'CRITICAL')
                          high = sum(1 for c in cves if c.get('severity', '').upper() == 'HIGH')

                          print(f"  Total: {len(cves)} CVEs (Critical: {critical}, High: {high}, KEV: {kev_count})")
                      else:
                          # Save empty file to indicate we checked
                          save_cve_json(app_key, app_name, [])
                          print(f"  No CVEs found")

                  except Exception as e:
                      print(f"  ERROR: {e}")
                      errors.append((app_key, str(e)))
                      import traceback
                      traceback.print_exc()

              # Print summary
              print("\n" + "=" * 60)
              print("SCAN COMPLETE")
              print("=" * 60)
              print(f"Apps processed: {processed}")
              print(f"Errors: {len(errors)}")

              if errors:
                  print("\nErrors encountered:")
                  for app_key, error in errors:
                      print(f"  - {app_key}: {error}")

              print("\nDone!")

          if __name__ == '__main__':
              main()
          PYTHON_SCRIPT

          python check_cves.py

      - name: Commit and push CVE files
        run: |
          if [[ -n $(git status --porcelain) ]]; then
            git config --global user.name 'GitHub Action'
            git config --global user.email 'action@github.com'
            git add CVE/
            git commit -m "Update CVE data [skip ci]"
            git push
          else
            echo "No changes to commit"
          fi
