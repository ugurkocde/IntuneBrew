name: Auto-Approve App Request

on:
  issues:
    types: [labeled]

# Queue approvals - only one can run at a time
concurrency:
  group: auto-approve-app-request
  cancel-in-progress: false

jobs:
  auto-approve:
    # Only run if the issue is labeled with 'auto-approved'
    if: github.event.label.name == 'auto-approved'
    runs-on: ubuntu-latest

    permissions:
      contents: write
      issues: write
      actions: write

    steps:
      - name: Post progress comment
        id: progress
        uses: actions/github-script@v7
        with:
          script: |
            const { data: comment } = await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## Auto-Approval in Progress\n\nThis app request was automatically validated and is being processed.\n\n- [ ] Parsing app information\n- [ ] Adding to supported apps list\n- [ ] Committing changes\n- [ ] Triggering build workflow`
            });
            core.setOutput('comment_id', comment.id);

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests

      - name: Add app to list
        id: add-app
        env:
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          COMMENT_BODY: ""
        run: python .github/scripts/add_new_app.py

      - name: Commit changes
        if: steps.add-app.outputs.app_added == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add .github/scripts/collect_app_info.py
          git commit -m "Add ${{ steps.add-app.outputs.commit_message }}"
          git push

      # Build is auto-triggered by push to main (collect_app_info.py change)

      - name: Comment success
        if: steps.add-app.outputs.app_added == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const appsJson = `${{ steps.add-app.outputs.apps_json }}`;
            const commentId = ${{ steps.progress.outputs.comment_id }};

            let apps = [];
            try {
              apps = JSON.parse(appsJson);
            } catch (e) {
              // Fallback for single app
              apps = [{
                name: '${{ steps.add-app.outputs.app_name }}',
                cask: '${{ steps.add-app.outputs.cask_name }}',
                type: '${{ steps.add-app.outputs.app_type }}'
              }];
            }

            let body = `## Auto-Approved\n\n`;
            body += `This app request was automatically validated and approved.\n\n`;
            body += `- [x] Parsing app information\n`;
            body += `- [x] Adding to supported apps list\n`;
            body += `- [x] Committing changes\n`;
            body += `- [x] Triggering build workflow\n\n`;

            body += `| App Name | Cask | Type |\n|----------|------|------|\n`;
            let hasPkg = false;
            for (const app of apps) {
              body += `| ${app.name} | \`${app.cask}\` | \`${app.type}\` |\n`;
              if (app.type === 'pkg') hasPkg = true;
            }

            if (hasPkg) {
              body += `\n> **Note:** If the build fails for PKG apps, they may be PKG-in-PKG. Move them from \`pkg_urls\` to \`pkg_in_pkg_urls\` in \`collect_app_info.py\`.\n`;
            }

            body += `\nThe build has been triggered. Track progress: [Actions](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/workflows/build-app-packages.yml)`;

            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: body
            });

      - name: Close issue
        if: steps.add-app.outputs.app_added == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              state: 'closed',
              labels: [...context.payload.issue.labels.map(l => l.name), 'approved']
            });

      - name: Comment failure
        if: failure() || steps.add-app.outputs.app_added == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const error = `${{ steps.add-app.outputs.error_message }}` || 'Unknown error';
            const commentId = ${{ steps.progress.outputs.comment_id || 0 }};

            const body = `## Auto-Approval Failed\n\n- [x] Parsing app information\n- [ ] Adding to supported apps list\n- [ ] Committing changes\n- [ ] Triggering build workflow\n\n**Error:** ${error}\n\nThis issue has been flagged for manual review.`;

            if (commentId) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: commentId,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

            // Remove auto-approved label and add needs-review
            await github.rest.issues.removeLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              name: 'auto-approved'
            }).catch(() => {});

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['needs-review']
            });
